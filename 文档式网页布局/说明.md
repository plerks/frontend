仿照的是vue3官网的布局方式

这个要查看的话，得用server的方式(比如用VSCode的Live Server插件)打开1.html，然后点标题1。直接用浏览器打开文件(file协议)，路由时会有问题(路由改变时浏览器会去找文件，然后找不到报错)。

这里要在正文段落上做锚点，而锚点和hash模式的路由有冲突，所以这里用了history模式的路由。

由于路由的原因，路由到某个标题后，点浏览器刷新会出错。

进度检测方式是scroll事件时通过元素位置检测paragraph是否出现在视口，之前(截止commit 834b0e36a3477de83573de9e42021fc9a221049f)用的是IntersectionObserver判断元素出现在视口，但是用IntersectionObserver的话，只能检测与视口交叉度变化，假如一个paragraph完整在视口中(比视口高度小)，然后滑动到页面头部，这时候IntersectionObserver就检测不到，这样就可能有一种情况：paragraph1完全在视口，然后这时候paragraph2滚动进来，这时候IntersectionObserver回调的entries里就只有paragraph2，但是这时候的阅读进度应该保持在paragraph1。之前用的办法是计算高度，用IntersectionObserver的负rootMargin把视口检测区域压到header的位置，然后判断paragraph-title和header位置的交叉。但是带来的问题是resize时之前计算出来的负rootMargin就不对，重新改IntersectionObserver又有点麻烦。总之换成了scroll时通过元素位置检测paragraph是否出现在视口，不过这样性能开销会比IntersectionObserver大一点