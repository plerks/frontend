仿照的是vue3官网的布局方式

这个要查看的话，得用server的方式(比如用VSCode的Live Server插件)打开1.html，然后点标题1。直接用浏览器打开文件(file协议)，路由时会有问题(路由改变时浏览器会去找文件，然后找不到报错)。

这里要在正文段落上做锚点，而锚点和hash模式的路由有冲突，所以这里用了history模式的路由。

由于路由的原因，路由到某个标题后，点浏览器刷新会出错。

正文滑动进度检测用的是IntersectionObserver，把root(这里是viewport)用负的rootMargin压缩到了header的位置，然后target与root出现相交时更新activeIndex。不过还有个隐藏的问题是viewport高度改变时(比如打开了开发者工具或者浏览器窗口resize)，滑动进度检测会不对。按理说在resize事件时重新计算rootMagin就行，不过没看到IntersectionObserver有创建后更新options的API，把options提到data里，然后resize时直接改new IntersectionObserver时传进去的data里的options应该是不起作用的。所以这种实现方式，不好应对viewport高度改变的情况(主要更新不了创建好了的IntersectionObserver的rootMargin，弄得再麻烦点大概能resize时把旧的IntersectionObserver删掉创建个新的)。

还有个极端情况是，点击页面中的锚点链接(正文中的#或者右侧目录中的某一条)，在滚动还没完成时，马上鼠标中键滚动一下打断页面滚动，右侧目录进度会没变过去(因为activeIndex没被IntersectionObserver更新)，不过问题不大，而且既然页面滚动被打断了，右侧目录进度好像确实不该变，不管了。